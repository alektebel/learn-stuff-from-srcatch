"""
Advanced Backtesting Engine - Template
=======================================
This module implements a professional-grade backtesting framework with realistic
market simulation and performance analysis.

TODO: Implement the following components:
1. Event-driven backtesting engine
2. Walk-forward optimization
3. Monte Carlo simulation
4. Realistic slippage and market impact modeling
5. Performance attribution analysis

Learning objectives:
- Build event-driven architecture
- Implement walk-forward testing
- Understand slippage and market impact
- Perform Monte Carlo analysis
- Attribute performance to different factors
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Optional, Callable
from datetime import datetime, timedelta
from enum import Enum
from abc import ABC, abstractmethod
import warnings
warnings.filterwarnings('ignore')


class Event(ABC):
    """
    Base class for events in event-driven backtesting.
    
    TODO 1: Define event types
    - Market event (new data bar)
    - Signal event (strategy generates signal)
    - Order event (order placed)
    - Fill event (order executed)
    """
    
    @abstractmethod
    def __str__(self):
        pass


class MarketEvent(Event):
    """
    Represents new market data availability.
    
    TODO 2: Implement market event
    - Triggered when new bar data available
    - Contains timestamp and symbol info
    """
    
    def __init__(self, timestamp: datetime, symbols: List[str]):
        """
        Initialize market event.
        
        Args:
            timestamp: Event timestamp
            symbols: List of symbols with new data
        """
        self.type = 'MARKET'
        self.timestamp = timestamp
        self.symbols = symbols
    
    def __str__(self):
        return f"MarketEvent({self.timestamp}, {self.symbols})"


class SignalEvent(Event):
    """
    Represents a trading signal from strategy.
    
    TODO 3: Implement signal event
    - Contains symbol, direction, strength
    - Generated by strategy
    """
    
    def __init__(
        self,
        timestamp: datetime,
        symbol: str,
        signal_type: str,
        strength: float = 1.0
    ):
        """
        Initialize signal event.
        
        Args:
            timestamp: Signal timestamp
            symbol: Trading symbol
            signal_type: 'LONG' or 'SHORT' or 'EXIT'
            strength: Signal strength (0-1)
        """
        self.type = 'SIGNAL'
        self.timestamp = timestamp
        self.symbol = symbol
        self.signal_type = signal_type
        self.strength = strength
    
    def __str__(self):
        return f"SignalEvent({self.timestamp}, {self.symbol}, {self.signal_type}, {self.strength})"


class OrderEvent(Event):
    """
    Represents an order to be executed.
    
    TODO 4: Implement order event
    - Contains order details
    - Sent to execution handler
    """
    
    def __init__(
        self,
        timestamp: datetime,
        symbol: str,
        order_type: str,
        quantity: int,
        direction: str,
        limit_price: Optional[float] = None
    ):
        """
        Initialize order event.
        
        Args:
            timestamp: Order timestamp
            symbol: Trading symbol
            order_type: 'MARKET' or 'LIMIT'
            quantity: Number of shares
            direction: 'BUY' or 'SELL'
            limit_price: Limit price for limit orders
        """
        self.type = 'ORDER'
        self.timestamp = timestamp
        self.symbol = symbol
        self.order_type = order_type
        self.quantity = quantity
        self.direction = direction
        self.limit_price = limit_price
    
    def __str__(self):
        return f"OrderEvent({self.timestamp}, {self.symbol}, {self.direction}, {self.quantity})"


class FillEvent(Event):
    """
    Represents executed order with actual fill details.
    
    TODO 5: Implement fill event
    - Contains actual execution price
    - Includes commission and slippage
    """
    
    def __init__(
        self,
        timestamp: datetime,
        symbol: str,
        quantity: int,
        direction: str,
        fill_price: float,
        commission: float,
        slippage: float = 0.0
    ):
        """
        Initialize fill event.
        
        Args:
            timestamp: Fill timestamp
            symbol: Trading symbol
            quantity: Filled quantity
            direction: 'BUY' or 'SELL'
            fill_price: Actual fill price
            commission: Commission paid
            slippage: Slippage cost
        """
        self.type = 'FILL'
        self.timestamp = timestamp
        self.symbol = symbol
        self.quantity = quantity
        self.direction = direction
        self.fill_price = fill_price
        self.commission = commission
        self.slippage = slippage
    
    def __str__(self):
        return f"FillEvent({self.timestamp}, {self.symbol}, {self.direction}, {self.quantity}@{self.fill_price})"


class DataHandler(ABC):
    """
    Abstract base class for data handling.
    
    TODO 6: Define data handler interface
    - Provide bars sequentially (no look-ahead)
    - Support multiple symbols
    - Handle missing data
    """
    
    @abstractmethod
    def get_latest_bars(self, symbol: str, n: int = 1) -> pd.DataFrame:
        """Get latest N bars for symbol."""
        pass
    
    @abstractmethod
    def update_bars(self) -> bool:
        """Update to next bar. Returns False if no more data."""
        pass


class HistoricDataHandler(DataHandler):
    """
    Handles historical data for backtesting.
    
    TODO 7: Implement historic data handler
    - Load all data at start
    - Serve bars sequentially
    - No look-ahead bias
    """
    
    def __init__(self, data: Dict[str, pd.DataFrame]):
        """
        Initialize with historical data.
        
        Args:
            data: Dictionary mapping symbols to DataFrames
        
        TODO: Set up data structures
        - Store all historical data
        - Initialize bar index
        - Create latest bars dict
        """
        self.data = data
        self.symbols = list(data.keys())
        self.bar_index = 0
        self.latest_bars = {s: [] for s in self.symbols}
        
        # Get all unique timestamps across all symbols
        all_timestamps = set()
        for df in data.values():
            all_timestamps.update(df.index)
        self.timestamps = sorted(list(all_timestamps))
        
        pass
    
    def get_latest_bars(self, symbol: str, n: int = 1) -> pd.DataFrame:
        """
        Get latest N bars for symbol.
        
        Args:
            symbol: Trading symbol
            n: Number of bars to return
        
        Returns:
            DataFrame with latest N bars
        
        TODO 8: Return latest bars
        - Return last N bars from latest_bars
        - Never return future data
        - Handle case where less than N bars available
        """
        # TODO: Implement get latest bars
        pass
    
    def update_bars(self) -> bool:
        """
        Update to next bar for all symbols.
        
        Returns:
            True if more data available, False otherwise
        
        TODO 9: Implement bar update
        - Move to next timestamp
        - Update latest_bars for each symbol
        - Return False when no more data
        - Handle missing data for some symbols
        """
        # TODO: Implement bar update
        pass
    
    def get_latest_bar_datetime(self) -> datetime:
        """Get timestamp of latest bar."""
        if self.bar_index > 0:
            return self.timestamps[self.bar_index - 1]
        return None


class ExecutionHandler:
    """
    Simulates order execution with realistic market effects.
    
    TODO 10: Implement execution simulation
    - Market orders with slippage
    - Limit orders with partial fills
    - Market impact modeling
    """
    
    def __init__(
        self,
        data_handler: DataHandler,
        commission_model: Callable = None,
        slippage_model: Callable = None
    ):
        """
        Initialize execution handler.
        
        Args:
            data_handler: Data handler for price lookup
            commission_model: Function to calculate commission
            slippage_model: Function to calculate slippage
        
        TODO: Set up execution models
        """
        self.data_handler = data_handler
        self.commission_model = commission_model or self.default_commission
        self.slippage_model = slippage_model or self.default_slippage
        pass
    
    def default_commission(self, quantity: int, price: float) -> float:
        """
        Default commission model.
        
        TODO 11: Implement commission calculation
        - Typical: $0.005 per share, min $1
        - Or percentage based: 0.1% of trade value
        """
        return max(1.0, abs(quantity) * 0.005)
    
    def default_slippage(
        self,
        symbol: str,
        quantity: int,
        order_type: str
    ) -> float:
        """
        Default slippage model.
        
        Args:
            symbol: Trading symbol
            quantity: Order quantity
            order_type: 'MARKET' or 'LIMIT'
        
        Returns:
            Slippage in price units
        
        TODO 12: Implement slippage model
        - Market orders: 0.1% slippage
        - Larger orders: more slippage (price impact)
        - Consider volatility and liquidity
        - Slippage = base_rate + impact_rate * (quantity / avg_volume)
        """
        # TODO: Calculate realistic slippage
        pass
    
    def execute_order(self, order: OrderEvent) -> FillEvent:
        """
        Execute order and return fill event.
        
        Args:
            order: Order to execute
        
        Returns:
            Fill event with execution details
        
        TODO 13: Implement order execution
        - Get current price from data handler
        - Calculate slippage
        - Calculate commission
        - Create and return fill event
        - Handle limit orders (may not fill)
        """
        # TODO: Implement order execution
        pass


class Portfolio:
    """
    Tracks positions and portfolio value.
    
    TODO 14: Implement portfolio tracking
    - Update positions from fills
    - Calculate portfolio value
    - Track realized and unrealized P&L
    """
    
    def __init__(
        self,
        data_handler: DataHandler,
        initial_capital: float = 100000.0
    ):
        """
        Initialize portfolio.
        
        Args:
            data_handler: Data handler for price lookup
            initial_capital: Starting capital
        
        TODO: Initialize portfolio state
        """
        self.data_handler = data_handler
        self.initial_capital = initial_capital
        self.current_cash = initial_capital
        self.positions = {}  # symbol -> quantity
        self.holdings = []  # List of portfolio values over time
        self.trades = []  # List of all trades
        pass
    
    def update_signal(self, signal: SignalEvent) -> Optional[OrderEvent]:
        """
        Generate order from signal.
        
        Args:
            signal: Signal event
        
        Returns:
            Order event or None
        
        TODO 15: Implement signal to order conversion
        - Calculate position size based on signal strength
        - Check available capital
        - Generate appropriate order
        - Consider existing positions
        """
        # TODO: Convert signal to order
        pass
    
    def update_fill(self, fill: FillEvent):
        """
        Update portfolio from fill.
        
        Args:
            fill: Fill event
        
        TODO 16: Update portfolio state
        - Update cash (subtract cost + commission)
        - Update positions
        - Record trade in history
        - Calculate realized P&L if closing position
        """
        # TODO: Update portfolio from fill
        pass
    
    def update_portfolio_value(self):
        """
        Calculate current portfolio value.
        
        TODO 17: Calculate portfolio value
        - Sum: cash + sum(position_qty * current_price)
        - Store in holdings history
        - Include unrealized P&L
        """
        # TODO: Calculate and record portfolio value
        pass
    
    def get_equity_curve(self) -> pd.Series:
        """
        Get portfolio equity curve.
        
        Returns:
            Series of portfolio values over time
        
        TODO 18: Return equity curve
        - Convert holdings to Series
        - Index by timestamp
        """
        # TODO: Return equity curve
        pass


class BacktestEngine:
    """
    Main backtesting engine with event-driven architecture.
    
    TODO 19: Implement event-driven backtest
    - Process events in sequence
    - Maintain event queue
    - Coordinate all components
    """
    
    def __init__(
        self,
        data: Dict[str, pd.DataFrame],
        strategy_class: type,
        initial_capital: float = 100000.0,
        **strategy_params
    ):
        """
        Initialize backtest engine.
        
        Args:
            data: Historical data for all symbols
            strategy_class: Strategy class to instantiate
            initial_capital: Starting capital
            **strategy_params: Parameters for strategy
        
        TODO: Initialize all components
        """
        self.data_handler = HistoricDataHandler(data)
        self.execution_handler = ExecutionHandler(self.data_handler)
        self.portfolio = Portfolio(self.data_handler, initial_capital)
        self.strategy = strategy_class(self.data_handler, **strategy_params)
        self.events = []
        self.results = {}
        pass
    
    def run(self):
        """
        Run the backtest.
        
        TODO 20: Implement main backtest loop
        - While data available:
          1. Update bars -> generate MarketEvent
          2. Strategy processes market event -> generates SignalEvents
          3. Portfolio converts signals -> generates OrderEvents
          4. Execution handler executes orders -> generates FillEvents
          5. Portfolio updates from fills
          6. Update portfolio value
        - Calculate final results
        """
        # TODO: Implement backtest loop
        pass
    
    def calculate_performance(self) -> Dict:
        """
        Calculate comprehensive performance metrics.
        
        Returns:
            Dictionary with all performance metrics
        
        TODO 21: Calculate performance metrics
        - Total return
        - Sharpe ratio
        - Sortino ratio
        - Max drawdown
        - Win rate
        - Profit factor
        - Calmar ratio
        - Average trade P&L
        """
        # TODO: Calculate metrics
        pass


class WalkForwardOptimizer:
    """
    Performs walk-forward optimization.
    
    TODO 22: Implement walk-forward testing
    - Split data into train/test windows
    - Optimize on train, test on out-of-sample
    - Roll forward through time
    """
    
    def __init__(
        self,
        data: Dict[str, pd.DataFrame],
        strategy_class: type,
        param_grid: Dict
    ):
        """
        Initialize walk-forward optimizer.
        
        Args:
            data: Historical data
            strategy_class: Strategy to optimize
            param_grid: Dictionary of parameters to test
        
        TODO: Set up optimization
        """
        self.data = data
        self.strategy_class = strategy_class
        self.param_grid = param_grid
        self.results = []
        pass
    
    def optimize_window(
        self,
        train_data: Dict[str, pd.DataFrame]
    ) -> Dict:
        """
        Optimize parameters on training window.
        
        Args:
            train_data: Training data
        
        Returns:
            Best parameters
        
        TODO 23: Implement parameter optimization
        - Test all parameter combinations
        - Run backtest for each
        - Select best based on Sharpe ratio (or other metric)
        - Avoid overfitting (use simple strategies)
        """
        # TODO: Optimize parameters
        pass
    
    def run_walk_forward(
        self,
        train_period: int = 252,  # days
        test_period: int = 63,  # days
        step_size: int = 21  # days
    ) -> Dict:
        """
        Run walk-forward optimization.
        
        Args:
            train_period: Training window size
            test_period: Testing window size
            step_size: How many days to roll forward
        
        Returns:
            Dictionary with all results
        
        TODO 24: Implement walk-forward process
        - Split data into overlapping windows
        - For each window:
          1. Optimize on training data
          2. Test on out-of-sample data
          3. Record results
        - Combine all out-of-sample results
        - Report overall performance
        """
        # TODO: Run walk-forward optimization
        pass


class MonteCarloSimulator:
    """
    Performs Monte Carlo simulation on backtest results.
    
    TODO 25: Implement Monte Carlo analysis
    - Resample trades randomly
    - Generate distribution of outcomes
    - Calculate confidence intervals
    """
    
    def __init__(self, trades: List[Dict]):
        """
        Initialize Monte Carlo simulator.
        
        Args:
            trades: List of trade dictionaries with P&L
        
        TODO: Store trades
        """
        self.trades = trades
        pass
    
    def simulate(self, n_simulations: int = 1000) -> Dict:
        """
        Run Monte Carlo simulations.
        
        Args:
            n_simulations: Number of simulations to run
        
        Returns:
            Dictionary with simulation results
        
        TODO 26: Run Monte Carlo simulation
        - For each simulation:
          1. Randomly resample trades (with replacement)
          2. Calculate equity curve
          3. Calculate metrics (return, drawdown, etc.)
        - Aggregate results across simulations
        - Calculate confidence intervals
        - Return distribution of outcomes
        """
        # TODO: Run simulations
        pass
    
    def calculate_risk_of_ruin(
        self,
        ruin_threshold: float = 0.2
    ) -> float:
        """
        Calculate probability of losing >X% of capital.
        
        Args:
            ruin_threshold: Loss threshold (0.2 = 20% loss)
        
        Returns:
            Probability of ruin
        
        TODO 27: Calculate risk of ruin
        - Run simulations
        - Count how many simulations exceed loss threshold
        - Return percentage
        """
        # TODO: Calculate risk of ruin
        pass


class PerformanceAttributor:
    """
    Attributes performance to different factors.
    
    TODO 28: Implement performance attribution
    - Break down returns by source
    - Identify key contributors
    """
    
    def __init__(self, trades: List[Dict], equity_curve: pd.Series):
        """
        Initialize performance attributor.
        
        Args:
            trades: List of all trades
            equity_curve: Portfolio equity curve
        
        TODO: Store data for attribution
        """
        self.trades = trades
        self.equity_curve = equity_curve
        pass
    
    def attribute_by_symbol(self) -> pd.DataFrame:
        """
        Attribute performance by symbol.
        
        Returns:
            DataFrame with P&L by symbol
        
        TODO 29: Attribute by symbol
        - Group trades by symbol
        - Sum P&L for each symbol
        - Calculate return contribution
        """
        # TODO: Attribute by symbol
        pass
    
    def attribute_by_period(
        self,
        period: str = 'M'
    ) -> pd.DataFrame:
        """
        Attribute performance by time period.
        
        Args:
            period: 'D', 'W', 'M', 'Q', 'Y'
        
        Returns:
            DataFrame with returns by period
        
        TODO 30: Attribute by time period
        - Resample equity curve to period
        - Calculate returns for each period
        - Identify best/worst periods
        """
        # TODO: Attribute by period
        pass
    
    def calculate_trade_statistics(self) -> Dict:
        """
        Calculate detailed trade statistics.
        
        Returns:
            Dictionary with trade stats
        
        TODO 31: Calculate trade statistics
        - Average trade P&L (winners vs losers)
        - Average holding period
        - Win rate by symbol
        - Trade distribution analysis
        - Consecutive wins/losses
        """
        # TODO: Calculate trade stats
        pass


# Testing and example usage
if __name__ == "__main__":
    """
    TODO 32: Test your implementation
    
    Test cases to implement:
    1. Test event-driven backtest with simple strategy
    2. Compare to vectorized backtest (should be similar)
    3. Test walk-forward optimization
    4. Run Monte Carlo simulation
    5. Perform performance attribution
    """
    
    print("Test 1: Event-Driven Backtest...")
    # TODO: Create simple strategy and run backtest
    
    print("\nTest 2: Walk-Forward Optimization...")
    # TODO: Test walk-forward with parameter grid
    
    print("\nTest 3: Monte Carlo Simulation...")
    # TODO: Run Monte Carlo on backtest results
    
    print("\nTest 4: Performance Attribution...")
    # TODO: Attribute returns by symbol and period
    
    print("\nAll tests completed!")


"""
Implementation Guidelines:
==========================

Phase 1: Event-Driven Architecture (60 minutes)
- Implement all event classes
- Build DataHandler with no look-ahead
- Create ExecutionHandler with realistic fills
- Test event flow manually
- Key: Ensure no future data leakage

Phase 2: Portfolio and Engine (60 minutes)
- Implement Portfolio tracking
- Build main BacktestEngine
- Process events in correct order
- Test with simple MA crossover strategy
- Verify results match expectations

Phase 3: Walk-Forward Testing (45 minutes)
- Implement window splitting
- Optimize on training data
- Test on out-of-sample data
- Roll forward through time
- Compare to simple backtest

Phase 4: Monte Carlo Analysis (45 minutes)
- Resample trades randomly
- Calculate distribution of outcomes
- Compute confidence intervals
- Assess risk of ruin
- Understand variability in results

Phase 5: Performance Attribution (30 minutes)
- Break down returns by symbol
- Analyze by time period
- Calculate trade statistics
- Identify performance drivers
- Understand what worked and why

Tips:
- Event-driven prevents look-ahead bias
- Walk-forward tests robustness
- Monte Carlo shows outcome distribution
- Slippage matters more than you think
- Always test out-of-sample
- Commission compounds quickly

Common Pitfalls:
- Look-ahead bias in data handling
- Unrealistic execution assumptions
- Not accounting for slippage
- Over-optimization on training data
- Ignoring transaction costs
- Cherry-picking best parameters
- Not testing on multiple time periods

Key Metrics:
- Sharpe Ratio: Risk-adjusted returns
- Sortino Ratio: Downside risk only
- Calmar Ratio: Return / Max Drawdown
- Win Rate: % profitable trades
- Profit Factor: Gross profit / Gross loss
- Max Drawdown: Worst peak-to-trough

Walk-Forward Results:
- Out-of-sample performance always worse than in-sample
- Significant degradation suggests overfitting
- Consistent out-of-sample profits = robust strategy
- Typical Sharpe degradation: 30-50%

Monte Carlo Insights:
- Shows range of possible outcomes
- Risk of ruin is crucial metric
- 95% confidence interval often wide
- Small sample size = high variance
- More trades = more reliable statistics

Performance Attribution:
- Identify which symbols contribute most
- Find seasonal patterns
- Detect regime changes
- Understand strategy behavior
- Guide future improvements

Resources:
- "Advances in Financial Machine Learning" by Marcos LÃ³pez de Prado
- "Quantitative Trading" by Ernie Chan
- "Systematic Trading" by Robert Carver
- Event-driven architecture patterns
"""
