-- Natural Numbers and Mathematical Induction in Lean - Template
-- This file guides you through the Peano axioms and proof by induction
-- Essential foundation for all algebraic structures in Galois theory

/-
LEARNING OBJECTIVES:
1. Understand inductive definition of natural numbers
2. Master mathematical induction proofs
3. Define addition and multiplication recursively
4. Prove properties of arithmetic operations
5. Understand strong induction and well-ordering principle
6. Develop intuition for recursive proofs needed in algebra
-/

-- ============================================================================
-- PART 1: PEANO AXIOMS AND BASIC PROPERTIES
-- ============================================================================

-- Note: Lean already has Nat built-in, but we'll define our own for learning
-- Uncomment to use custom definition, or use built-in Nat

namespace MyNat

-- Inductive definition of natural numbers (Peano axioms)
inductive MyNat : Type
  | zero : MyNat
  | succ : MyNat → MyNat

-- Notation for convenience
notation "ℕ" => MyNat
notation "O" => MyNat.zero
notation "S" => MyNat.succ

-- TODO 1.1: Prove zero is not a successor
-- This is one of Peano's axioms, provable from inductive definition
theorem zero_ne_succ (n : ℕ) : O ≠ S n :=
  sorry  -- TODO: Use noConfusion or cases to show contradiction

-- TODO 1.2: Prove successor is injective
-- If S m = S n, then m = n
theorem succ_injective {m n : ℕ} : S m = S n → m = n :=
  sorry  -- TODO: Use MyNat.succ.injEq or cases

-- TODO 1.3: State the induction principle explicitly
-- (This is automatically generated by Lean's inductive definition)
axiom induction_principle : ∀ (P : ℕ → Prop),
  P O →                           -- Base case
  (∀ n, P n → P (S n)) →         -- Inductive step
  (∀ n, P n)                      -- Conclusion

end MyNat

-- For the rest, we'll use Lean's built-in Nat which has more support

-- ============================================================================
-- PART 2: ADDITION
-- ============================================================================

section Addition

-- Addition is defined recursively in Lean:
-- 0 + n = n
-- (m + 1) + n = (m + n) + 1

-- TODO 2.1: Prove 0 + n = n (definitional, but good to state)
theorem zero_add (n : Nat) : 0 + n = n :=
  sorry  -- TODO: This is true by definition, use rfl

-- TODO 2.2: Prove n + 0 = n (requires induction!)
-- This is NOT definitional - addition is defined on the first argument
theorem add_zero (n : Nat) : n + 0 = n := by
  sorry  -- TODO: Use induction on n
  -- Base: 0 + 0 = 0 (by definition)
  -- Step: Assume k + 0 = k, prove (k+1) + 0 = k+1
  --       (k+1) + 0 = (k+0) + 1 = k + 1 by IH

-- TODO 2.3: Prove successor on right: n + (m + 1) = (n + m) + 1
theorem add_succ (n m : Nat) : n + (m + 1) = (n + m) + 1 := by
  sorry  -- TODO: Use induction on n
  -- Base: 0 + (m+1) = 0 + m + 1 (by definition)
  -- Step: Assume n + (m+1) = (n+m) + 1, prove (n+1) + (m+1) = ((n+1)+m) + 1

-- TODO 2.4: Prove addition is commutative
theorem add_comm (n m : Nat) : n + m = m + n := by
  sorry  -- TODO: Use induction on n, need add_zero and add_succ
  -- Base: 0 + m = m + 0
  -- Step: Assume k + m = m + k, prove (k+1) + m = m + (k+1)

-- TODO 2.5: Prove addition is associative
theorem add_assoc (n m p : Nat) : (n + m) + p = n + (m + p) := by
  sorry  -- TODO: Use induction on n
  -- Base: (0 + m) + p = 0 + (m + p)
  -- Step: Assume (k+m)+p = k+(m+p), prove ((k+1)+m)+p = (k+1)+(m+p)

-- TODO 2.6: Prove left cancellation for addition
theorem add_left_cancel {n m k : Nat} : n + m = n + k → m = k := by
  sorry  -- TODO: Use induction on n
  -- Base: 0 + m = 0 + k → m = k (immediate)
  -- Step: Use successor injectivity and IH

-- TODO 2.7: Prove right cancellation for addition  
theorem add_right_cancel {n m k : Nat} : n + k = m + k → n = m := by
  sorry  -- TODO: Use commutativity to reduce to left cancellation

end Addition

-- ============================================================================
-- PART 3: MULTIPLICATION
-- ============================================================================

section Multiplication

-- Multiplication is defined recursively:
-- 0 * n = 0
-- (m + 1) * n = n + (m * n)

-- TODO 3.1: Prove 0 * n = 0 (definitional)
theorem zero_mul (n : Nat) : 0 * n = 0 :=
  sorry  -- TODO: This is true by definition

-- TODO 3.2: Prove n * 0 = 0 (requires induction)
theorem mul_zero (n : Nat) : n * 0 = 0 := by
  sorry  -- TODO: Use induction on n
  -- Base: 0 * 0 = 0
  -- Step: Assume k * 0 = 0, prove (k+1) * 0 = 0
  --       (k+1) * 0 = 0 + k*0 = 0 + 0 = 0

-- TODO 3.3: Prove 1 * n = n
theorem one_mul (n : Nat) : 1 * n = n := by
  sorry  -- TODO: Unfold definition: 1 * n = n + 0 * n = n + 0 = n

-- TODO 3.4: Prove n * 1 = n
theorem mul_one (n : Nat) : n * 1 = n := by
  sorry  -- TODO: Use induction, need add_zero and mul properties

-- TODO 3.5: Prove multiplication with successor
theorem mul_succ (n m : Nat) : n * (m + 1) = n * m + n := by
  sorry  -- TODO: Use induction on n
  -- Base: 0 * (m+1) = 0 * m + 0
  -- Step: Complex, use distributivity being built up

-- TODO 3.6: Prove right distributivity
theorem right_distrib (n m p : Nat) : (n + m) * p = n * p + m * p := by
  sorry  -- TODO: Use induction on n
  -- Base: (0 + m) * p = 0 * p + m * p
  -- Step: Use IH and associativity/commutativity of addition

-- TODO 3.7: Prove left distributivity
theorem left_distrib (n m p : Nat) : n * (m + p) = n * m + n * p := by
  sorry  -- TODO: Use induction on n
  -- Base: 0 * (m + p) = 0 * m + 0 * p
  -- Step: Use IH and rearrange additions

-- TODO 3.8: Prove multiplication is commutative
theorem mul_comm (n m : Nat) : n * m = m * n := by
  sorry  -- TODO: Use induction, needs mul_zero, mul_succ, commutativity of +

-- TODO 3.9: Prove multiplication is associative
theorem mul_assoc (n m p : Nat) : (n * m) * p = n * (m * p) := by
  sorry  -- TODO: Use induction on n
  -- Base: (0 * m) * p = 0 * (m * p)
  -- Step: Use right distributivity and IH

end Multiplication

-- ============================================================================
-- PART 4: ORDER RELATIONS
-- ============================================================================

section Order

-- Less than or equal is defined: m ≤ n iff ∃ k, m + k = n

-- TODO 4.1: Prove ≤ is reflexive
theorem le_refl (n : Nat) : n ≤ n :=
  sorry  -- TODO: Witness k = 0, show n + 0 = n

-- TODO 4.2: Prove ≤ is transitive
theorem le_trans {n m p : Nat} : n ≤ m → m ≤ p → n ≤ p :=
  sorry  -- TODO: If n + k₁ = m and m + k₂ = p, then n + (k₁+k₂) = p

-- TODO 4.3: Prove ≤ is antisymmetric
theorem le_antisymm {n m : Nat} : n ≤ m → m ≤ n → n = m :=
  sorry  -- TODO: If n + k₁ = m and m + k₂ = n, show k₁ = k₂ = 0

-- TODO 4.4: Prove ≤ is total (trichotomy)
theorem le_total (n m : Nat) : n ≤ m ∨ m ≤ n :=
  sorry  -- TODO: Use strong induction or compare n and m

-- TODO 4.5: Prove 0 ≤ n for all n
theorem zero_le (n : Nat) : 0 ≤ n :=
  sorry  -- TODO: Witness k = n

-- TODO 4.6: Prove n < m + 1 iff n ≤ m
theorem lt_succ_iff {n m : Nat} : n < m + 1 ↔ n ≤ m :=
  sorry  -- TODO: Unfold definitions carefully

end Order

-- ============================================================================
-- PART 5: STRONG INDUCTION AND WELL-ORDERING
-- ============================================================================

section StrongInduction

-- TODO 5.1: State and prove strong induction principle
-- Strong induction: If P(n) follows from P(k) for all k < n, then P(n) for all n
theorem strong_induction (P : Nat → Prop) 
    (h : ∀ n, (∀ m, m < n → P m) → P n) : ∀ n, P n := by
  sorry  -- TODO: This can be proved from regular induction
  -- Strategy: Define Q(n) := ∀ m < n, P m, prove Q by induction

-- TODO 5.2: Prove well-ordering principle
-- Every non-empty set of natural numbers has a minimum element
theorem well_ordering (S : Set Nat) (h : ∃ n, n ∈ S) :
    ∃ m ∈ S, ∀ n ∈ S, m ≤ n := by
  sorry  -- TODO: Use strong induction
  -- For each n, if n ∈ S and no smaller element is in S, then n is minimum

-- TODO 5.3: Prove division algorithm
-- For any n and d > 0, ∃ unique q, r such that n = d*q + r and r < d
theorem division_algorithm (n d : Nat) (hd : 0 < d) :
    ∃ q r, n = d * q + r ∧ r < d ∧ 
           (∀ q' r', n = d * q' + r' ∧ r' < d → q = q' ∧ r = r') := by
  sorry  -- TODO: Use strong induction on n or well-ordering
  -- Existence: Subtract d repeatedly until remainder < d
  -- Uniqueness: If two representations, derive contradiction

end StrongInduction

-- ============================================================================
-- PART 6: ADVANCED THEOREMS
-- ============================================================================

section Advanced

-- TODO 6.1: Prove Binomial Theorem (for natural exponents)
-- This is complex and might be better left as an exercise marker
-- (n + m)^k = Σ C(k,i) * n^i * m^(k-i)

-- TODO 6.2: Prove fundamental theorem of arithmetic (sketch)
-- Every natural > 1 can be written uniquely as product of primes
-- This is a major theorem requiring much groundwork

-- TODO 6.3: Define factorial and prove basic properties
def factorial : Nat → Nat
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

theorem factorial_pos (n : Nat) : 0 < factorial n := by
  sorry  -- TODO: Use induction

-- TODO 6.4: Define binomial coefficients
def choose : Nat → Nat → Nat
  | n, 0 => 1
  | 0, k + 1 => 0
  | n + 1, k + 1 => choose n k + choose n (k + 1)

-- Pascal's identity
theorem pascal_identity (n k : Nat) :
    choose (n + 1) (k + 1) = choose n k + choose n (k + 1) := by
  sorry  -- TODO: This is definitional from the recursive definition

end Advanced

/-
IMPLEMENTATION GUIDE SUMMARY:

Part 1 - Peano Axioms:
  Understanding inductive types is key
  Successor injection and zero distinctness are fundamental
  These properties enable proof by induction
  
Part 2 - Addition:
  First experience with induction proofs!
  add_zero requires induction (not definitional)
  Build up: add_zero → add_succ → add_comm → add_assoc
  Each theorem depends on previous ones
  
Part 3 - Multiplication:
  Similar pattern to addition but more complex
  Need addition theorems for multiplication proofs
  Distributivity is crucial for later algebra
  Commutativity proof is challenging
  
Part 4 - Order:
  Order defined in terms of addition
  Prove partial order properties
  Totality requires careful induction
  Foundation for inequalities in analysis
  
Part 5 - Strong Induction:
  Can be derived from regular induction
  Essential for many number theory proofs
  Well-ordering equivalent to induction
  Division algorithm is first major application
  
Part 6 - Advanced:
  These are stretch goals
  Fundamental theorem of arithmetic is major
  Good preparation for polynomial factorization
  Binomial theorem connects to field theory

KEY INDUCTION PATTERNS:

Simple Induction Template:
  induction n with
  | zero =>
    -- Prove P(0)
  | succ n ih =>
    -- Assume P(n) as 'ih'
    -- Prove P(n+1)

Strong Induction Template:
  -- Define auxiliary predicate
  -- Prove by regular induction
  -- Extract strong induction from it

COMMON PITFALLS:
- Forgetting that addition is defined on first argument
- Not using previously proved lemmas
- Trying to prove commutativity before auxiliary lemmas
- Not simplifying enough in inductive step

TACTICS FOR INDUCTION PROOFS:
- induction n with | case1 => ... | case2 ih => ...
- rfl: Reflexivity (definitional equality)
- simp: Simplify using known lemmas
- rw [lemma]: Rewrite using lemma
- calc: Chain of equations (very useful!)

TIPS:
- Draw out small examples (n=0,1,2) to see pattern
- State lemmas before you need them
- Break complex proofs into smaller lemmas
- Use calc mode for long chains of equalities
- Compare with Mathlib's Nat proofs

NEXT STEPS:
After completing this file, you're ready for Groups.lean!
Induction is THE key technique in all subsequent algebraic proofs.
You'll use it to prove properties of groups, rings, and fields.
-/
